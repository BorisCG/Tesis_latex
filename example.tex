% Template:     Tesis LaTeX
% Documento:    Archivo de ejemplo
% Versión:      3.4.2 (07/02/2025)
% Codificación: UTF-8
%
% Autor: Pablo Pizarro R.
%        pablo@ppizarror.com
%
% Manual template: [https://latex.ppizarror.com/tesis]
% Licencia MIT:    [https://opensource.org/licenses/MIT]

% ------------------------------------------------------------------------------
% NUEVO CAPÍTULO
% ------------------------------------------------------------------------------
% A diferencia de Template-Informe, Template-Tesis requiere el uso de capítulos; las secciones, subsecciones, etc son parte de un capítulo. Se recomienda el uso de un capítulo en un archivo distinto
\chapter{Introduction}

\section{SMBH Formation Channels and the Collisional Paradigm}
\section{The Role of Gas in Dense Stellar Systems}
\section{Research Objectives and Thesis Outline}


% ------------------------------------------------------------------------------
% NUEVO CAPÍTULO
% ------------------------------------------------------------------------------
\chapter{Theoretical Framework}
\section{Density criterion for stellar collisions}
\section{Stars and gas in equilibrium}

\chapter{Numerical Methods}

\section{The AMUSE Framework}

In this work, we investigate the effect of gas on the formation seeds of SMBHs. In contrast with other works, we do not take into account gas accretion by stars, since we are interested exclusively in the gravitational interaction between gas and stars.

We require, in principle, three codes: one for the stars, one for the gas and a coupling code that handles gravitational interactions between gas and stars.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Esquemas/Codes_scheme.png} % Ruta relativa
	\caption{Schematic representation of the code coupling framework}
	\label{img:codes_scheme}
\end{figure}

The N-Body and SPH codes are accessed through the AMUSE interface, and coupled via an external code.


\section{N-body code: Ph4}

The proposed scenarios presented in (referencia a capitulo) require modeling dense stellar clusters. As we need to consider close encounters and collisions, a high-precision code is necessary.

The PH4 code from the AMUSE interface is used. In this section, we include a description of the code, and some external routines.

\subsection{Hermite integrator}

The Ph4 code uses a fourth-order Hermite integrator \cite{makino1992} for calculating the positions and velocities of stars due to gravity. This is a predictor-corrector method.

The fourth-order Hermite scheme is based on a precise calculation of the individual time step. Considering the particle $i$ with its own time $t_i$, time step $\Delta t_i$, position $\mathbf{x}_i$, velocity $\mathbf{v}_i$, acceleration $\mathbf{a}_i$ and jerk $\dot{\mathbf{a}}_i$, all calculated at time $t_i$. The integration algorithm proceeds as follows:

\begin{enumerate}
	\item Select the particle with the minimum $t_i + \Delta t_i$. Set the global time to $t=t_i + \Delta t_i$.
	\item Calculate the predicted positions ($\mathbf{x}_p$) and velocities ($\mathbf{v}_p$) for all particles, using the current values for $\mathbf{x}$, $\mathbf{v}$, $\mathbf{a}$, $\dot{\mathbf{a}}$. 
	\item Calculate the acceleration ($\mathbf{a}_i$) and jerk ($\dot{\mathbf{a}}_i$) for particle $i$ at time $t_i + \Delta t_i$ using the predicted positions and velocities.
	\item Calculate the second and third time derivatives of acceleration ($\mathbf{a}_i^{(2)}$ and $\mathbf{a}_i^{(3)}$) using Hermite interpolation.
	\item Apply corrections to the position and velocity of particle $i$.
	\item Calculate and update the time step $\Delta t_i$.
	\item Repeat the algorithm.
\end{enumerate}

A detailed derivation of the algorithm and the full set of equations are provided in Appendix~\ref{ap:A}. From Eqs.~(\ref{eq:ap_xpred}) and (\ref{eq:ap_velpred}), the predicted positions and velocities are:

\begin{align}
	\mathbf{x}_{p, j} &= \mathbf{x}_j + \mathbf{v}_j (t - t_j) + \frac{\mathbf{a}_{0,j}}{2} (t - t_j)^2 + \frac{\dot{\mathbf{a}}_{0,j}}{3!} (t - t_j)^3 \\
	\mathbf{v}_{p, j} &= \mathbf{v}_j + \mathbf{a}_{0,j} (t - t_j) + \frac{\dot{\mathbf{a}}_{0,j}}{2!} (t - t_j)^2
\end{align}

Here, $\mathbf{x}_j$ and $\mathbf{v}_j$ are the position and velocity of particle $j$ at time $t_j$. The current acceleration $\mathbf{a}_{0,j}$ and jerk $\dot{\mathbf{a}}_{0,j}$ are computed as:

 
\begin{align}
	\mathbf{a}_{0, j} &= \sum_{k \neq j} G m_k \frac{\mathbf{r}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{3/2}}\\
	\dot{\mathbf{a}}_{0, j} &= \sum_{k \neq j} G m_k \left[\frac{\mathbf{v}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{3/2}} - \frac{3(\mathbf{v}_{0,jk} \cdot \mathbf{r}_{0,jk})\mathbf{r}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{5/2}}\right] \\
	\mathbf{r}_{0,jk} &= \mathbf{r}_{k} - \mathbf{r}_{j} \\
	\mathbf{v}_{0,jk} &= \mathbf{v}_{k} - \mathbf{v}_{j}
\end{align}

Using Hermite interpolation, the second and third time derivatives of the acceleration can be estimated. This estimation is subsequently used to correct the positions and velocities. The relevant expressions, derived in the appendix, are:

\begin{align}
	\mathbf{a}^{(2)}_{0, i} &= \frac{-6(\mathbf{a}_{0, i} - \mathbf{a}_{1, i}) - \Delta t_i(4\dot{\mathbf{a}}_{0, i} + 2\dot{\mathbf{a}}_{1, i})}{{\Delta t_i}^2} \\
	\mathbf{a}^{(3)}_{0, i} &= \frac{12 (\mathbf{a}_{0, i} - \mathbf{a}_{1, i}) + 6(\dot{\mathbf{a}}_{0, i} + \dot{\mathbf{a}}_{1, i})\Delta t_i}{{\Delta t_i}^3}
\end{align}

The final corrected position and velocity of particle $i$ are then given by:

\begin{align}
	\mathbf{x}_i(t_i + \Delta t_i) =& \mathbf{x}_{p, i} + \frac{\mathbf{a}^{(2)}_{0, i} {\Delta t_i}^4}{24} + \frac{\mathbf{a}^{(3)}_{0, i} {\Delta t_i}^5}{120} \\
	\mathbf{v}_i(t_i + \Delta t_i) =& \mathbf{v}_{p, i} + \frac{\mathbf{a}^{(2)}_{0, i} {\Delta t_i}^3}{6} + \frac{\mathbf{a}^{(3)}_{0, i} {\Delta t_i}^4}{24}
\end{align}

These corrections incorporate terms up to fourth order. The main advantage of this method is that it only requires the explicit calculation of the acceleration and jerk at each step, with higher-order derivatives being obtained through the interpolation scheme.

\subsection{Block Time Steps}

An important part of the Hermite integrator is the time step calculation. The time step controls precision, energy conservation and integration time. While time steps are individual (each particle has its own), they are grouped into blocks for efficiency.

Time steps are set in two steps. First, a dynamic time step is calculated. Then, the time step is assigned using a block scheme. For the dynamical time step, the standard formula (\ref{eq:ap_tstep_std}) is used:

\begin{align}
	\Delta t_i = \sqrt{\eta \frac{|\mathbf{a}_{1, i}| |\mathbf{a}^{(2)}_{1, i}| + |\dot{\mathbf{a}}_{1, i}|^2}{|\dot{\mathbf{a}}_{1, i}| |\mathbf{a}^{(3)}_{1, i}| + |\mathbf{a}^{(2)}_{1, i}|^2}} \label{eq:3.11}
\end{align}

As can be seen, $\mathbf{a}_{1, i}$ and $\dot{\mathbf{a}}_{1, i}$ are calculated in each step, while $\mathbf{a}^{(3)}_{1, i}$ is constant. Only $\mathbf{a}^{(2)}_{1, i}$ needs to be estimated:

\begin{align}
	\mathbf{a}^{(2)}_{1, i} = \mathbf{a}^{(2)}_{0, i} + \Delta t_i \mathbf{a}^{(3)}_{1, i}
\end{align}

When the simulation begins, the initial time steps are calculated using (\ref{eq:ap_tstep_ini}):

\begin{align}
	\Delta t = \eta_s \frac{|\mathbf{a}|}{|\dot{\mathbf{a}}|} \label{eq:3.13}
\end{align}

The main algorithm of the Hermite 4th-order scheme evolves the particle with the minimum $t_j + \Delta t_j$. As it is expensive to evolve particles one by one, the goal is to assign particles to discrete time steps. In Ph4, time steps are set to powers of two of the N-body time units.

During initialization, the time step is calculated using Equation (\ref{eq:3.13}), and then set. Given the initial time step $\Delta t_{0, j}$, the N-body time $\tau$, and an integer $n$:

\begin{equation}
	0.5 < \frac{\tau 2^{n}}{\Delta t_{0, j}} < 1
\end{equation}

The time step is then set to $\tau 2^{n}$, with $n$ being able to be positive or negative.

As the model evolves, the new time step is computed using (\ref{eq:3.11}). The time step is halved if the calculated time step is smaller than the current time step, and doubled if it is larger than twice the current time step.

The advantage of this time step criterion is that the time step in the code is equal to or lower than that required by the dynamics. Moreover, since particles share the same time steps, they can be integrated simultaneously. Additionally, all particles can be synchronized, as their times are multiples of powers of two of the same time unit.

\subsection{Collisions and mergers}

Stellar collisions occur in two steps. First, the collision is detected by the AMUSE routines in PH4, and then it is handled externally. PH4 has support for stopping conditions, specifically for collision detection.

All particles in AMUSE have different properties: position, velocity, mass, radius, among others. When \texttt{collision\_detection} is enabled in PH4, the first filter is to check if two particles are closer than the sum of their radii:

\begin{equation}
	|\Delta \mathbf{x}| < r_i + r_j
\end{equation}

where $\Delta \mathbf{x}$ is the relative position vector between particles $i$ and $j$, and $r_i$, $r_j$ their respective radii. A second filter then verifies close encounters:

\begin{equation}
	\epsilon |\Delta \mathbf{x}| |\Delta \mathbf{v}| > \Delta \mathbf{x} \cdot \Delta \mathbf{v} 
\end{equation}

where $\Delta \mathbf{v}$ is the relative velocity vector and $\epsilon = 0.001$. This avoids cases where particle superposition results from hyperbolic encounters with predominantly tangential relative velocities.

The stopping conditions allow the user to implement custom handling routines. For these simulations, we simply conserve linear momentum. When \texttt{collision\_detection} is triggered, the code modifies the properties of one particle (preferentially the more massive one), setting its mass to the sum of the masses, its position to the center of mass, its velocity to the center-of-mass velocity, and its radius to conserve mass density:

\begin{align}
	m_{\text{new}} &= m_i + m_j \\
	\mathbf{x}_{\text{new}} &= \frac{m_i \mathbf{x}_{i} + m_j \mathbf{x}_{j}}{m_i + m_j} \\
	\mathbf{v}_{\text{new}} &= \frac{m_i \mathbf{v}_{i} + m_j \mathbf{v}_{j}}{m_i + m_j} \\
	r_{\text{new}} &= r_i \left(\frac{m_i + m_j}{m_i}\right)^{1/3} \\	
\end{align}

Finally, the other particle is removed from the simulation.

\subsection{Escaping stars}

After each analysis time step, potential escapers are identified through a multi-stage detection algorithm. To maintain mass and energy conservation, escaped stars are not removed from the simulation. Instead we add an extra attribute, \texttt{escaped} (all stars begin with \texttt{particles.escaped = False}), to track bound and unbound stars for subsequent analysis. The process begins with defining an appropriate length scale.

During initialization, the escape scale is defined as the minimum between ten times the virial radius and the Lagrangian radius containing the total mass: 

\begin{equation}
	r_{0, \text{esc}} = \min (10 \times r_{\text{vir}}, r_{100})
\end{equation}

where $r_{100}$ represents the Lagrangian radius containing the total stellar mass. In subsequent iterations, the escape distance is updated as:

\begin{equation}
	r_{\text{esc}} = \max (r_{\text{esc}}, 10 \times r_{b, \text{vir}})
\end{equation}

where $r_{b, \text{vir}}$ denotes the virial radius of bound stars.

The escape detection algorithm, executed at each time step, proceeds as follows:

\begin{enumerate}
	\item Compute the core center and identify stars beyond the escape radius
	\item Select gravitationally unbound stars
	\item Identify stars with outward radial motion
	\item Verify minimal gravitational influence on nearest neighbors
\end{enumerate}

The core center location is determined using a density-weighted scheme following \cite{1993MNRAS.261..497S}. For each star, the distance to its 7th nearest neighbor ($r_{i,7}$) is computed, and the density center is calculated as:

\begin{equation}
	\mathbf{x}_c = \frac{\sum_{i = 1}^{N} \mathbf{x}_i / r_{i,7}^3}{\sum_{i = 1}^{N} 1 / r_{i,7}^3} \label{eq:3.24}
\end{equation}

This formulation resembles a center of mass calculation but uses local stellar density instead of mass. Stars satisfying the condition

\begin{equation}
	|\mathbf{x}_i - \mathbf{x}_c| > r_{\text{esc}}
\end{equation}

are identified as potential escapers.

Gravitational unbinding is evaluated using the total energy $E_i = E_{p,i} + E_{k,i}$, where $E_{p,i}$ is the gravitational potential energy (including contributions from both stars and gas) and $E_{k,i}$ is the kinetic energy. Stars with $E_i \leq 0$ are considered bound, while those with $E_i > 0$ are classified as unbound. Among unbound stars, outward-moving candidates are identified through the condition:

\begin{equation}
	\Delta\mathbf{x}_i \cdot \Delta\mathbf{v}_i > 0
\end{equation}

where $\Delta\mathbf{x}_i = \mathbf{x}_i - \mathbf{x}_c$ and $\Delta\mathbf{v}_i = \mathbf{v}_i - \mathbf{v}_c$ represent position and velocity relative to the cluster center. Similar to (\ref{eq:3.24}), the velocity of the core center is computed as

\begin{equation}
	\mathbf{v}_c = \frac{\sum_{i = 1}^{N} \mathbf{v}_i m_i / r_{i,7}^3}{\sum_{i = 1}^{N} m_i / r_{i,7}^3}
\end{equation}

The final validation step quantifies the gravitational influence on neighboring stars. For each candidate escaper, the relative potential energy ($e_{p,i}$) and kinetic energy ($e_{k,i}$) with respect to its nearest neighbor are computed. The energy ratio is defined as:

\begin{equation}
	X_E := \frac{|e_{p,i}|}{e_{k,i}}
\end{equation}

Stars satisfying $X_E < 0.01$ are confirmed as escapers, ensuring minimal gravitational perturbation to neighboring stars. These stars are tagged as escapers (\texttt{particles.escaped = True}).

\section{SPH code: Fi}
\section{Coupling strategy: Bridge}

\chapter{Initial Conditions and Setup}             % ← NUEVO capítulo
\section{Stellar Cluster Models}
\section{Gas Configurations}
\section{Numerical Parameters}

\chapter{Results and analysis}
\section{Gas-Free Baseline Simulations}
\section{Effects of Gas Fraction on Collision Rates}
\section{Mass Spectrum Evolution and Massive Object Formation}
\section{Comparative Analysis Across Gas Fractions}

\chapter{Discussion and Conclusions}
\section{Interpretation of Gas-Induced Enhancements}
\section{Implications for SMBH Seed Formation}
\section{Limitations and Future Work}



% ------------------------------------------------------------------------------
% REFERENCIAS, revisar configuración \stylecitereferences
% ------------------------------------------------------------------------------
\bibliography{library}


% ------------------------------------------------------------------------------
% ANEXO
% Existe adicionalmente el entorno \begin{appendixd} que permite insertar
% \chapter y el entorno \begin{appendixdtitle}[style1] (4 estilos diferentes),
% el cual acepta \chapter y escribe el título de anexos encima
% ------------------------------------------------------------------------------
\begin{appendixs}
	\section{Fourth-Order Hermite Integration Scheme} \label{ap:A}
	The N-body code used in this work, \texttt{ph4}, is based on a fourth-order Hermite integrator. The following subsections describe in detail the individual time step scheme (ITS) from \cite{makino1992}, including the time step criterion in the N-body code.
	
	% Primer paso
	\subsection{Step 1: Particle selection}
	The first step is to select the next particle to be advanced. At any given time, each particle $j$ has its own mass $m_j$, time $t_j$, time step $\Delta t_j$, coordinates $\mathbf{x}_j$ and $\mathbf{v}_j$, acceleration $\mathbf{a}_j$ and jerk $\dot{\mathbf{a}}_j$ (with $\dot{\mathbf{a}}_j = \partial \mathbf{a}_j / \partial t$). The selected particle $i$ is the one satisfying the condition:
	
	\begin{equation}
		i = \arg\min_j(t_j + \Delta t_j)
	\end{equation}
	
	Note that always $t_j \leq t_i + \Delta t_i$, for all $j$. The current simulation time is then set to $t = t_i + \Delta t_i$.
	
	% Segundo paso
	\subsection{Step 2: Calculate the predicted position and velocities for all particles}
	
	The positions and velocities of all particles are predicted at time $t$, using a Taylor expansion up to third-order (jerk):
	\begin{align}
		\mathbf{x}_{p, j} &= \mathbf{x}_j + \mathbf{v}_j (t - t_j) + \frac{\mathbf{a}_{0,j}}{2!} (t - t_j)^2 + \frac{\dot{\mathbf{a}}_{0,j}}{3!} (t - t_j)^3 \label{eq:ap_xpred} \\
		\mathbf{v}_{p, j} &= \mathbf{v}_j + \mathbf{a}_{0,j} (t - t_j) + \frac{\dot{\mathbf{a}}_{0,j}}{2!} (t - t_j)^2 \label{eq:ap_velpred}
	\end{align}
	
	The acceleration is due only to gravitational force. The expression for each particle $j$ is:
	
	\begin{equation}
		\mathbf{a}_{0, j} = \sum_{k \neq j} G m_k \frac{\mathbf{r}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{3/2}} \label{eq:ap_accel}
	\end{equation}
	
	where $\epsilon$ is the softening parameter, and
	
	\begin{equation}
		\mathbf{r}_{0,jk} = \mathbf{r}_{k} - \mathbf{r}_{j}
	\end{equation}
	
	Differentiating Eq.~\eqref{eq:ap_accel} with respect to time yields the jerk:
	
	\begin{align}
		\dot{\mathbf{a}}_{0, j} &= \frac{\partial \mathbf{a}_j}{\partial t} \\
		&= \sum_{k \neq j} G m_k \frac{\partial}{\partial t}\frac{\mathbf{r}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{3/2}} \\
		\dot{\mathbf{a}}_{0, j} &= \sum_{k \neq j} G m_k \left[\frac{\mathbf{v}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{3/2}} - \frac{3(\mathbf{v}_{0,jk} \cdot \mathbf{r}_{0,jk})\mathbf{r}_{0,jk}}{(\mathbf{r}_{0,jk}^2 + \epsilon^2)^{5/2}}\right] \label{eq:ap_jerk}
	\end{align}
	
	where
	
	\begin{equation}
		\mathbf{v}_{0,jk} = \mathbf{v}_{k} - \mathbf{v}_{j}
	\end{equation}
	
	% Tercer paso
	\subsection{Step 3: Calculate acceleration and jerk for particle $i$}
	
	Similar to equations (\ref{eq:ap_accel}) and (\ref{eq:ap_jerk}), the acceleration and jerk are calculated using the predicted positions and velocity:
	
	\begin{align}
		\mathbf{a}_{1, i} &= \sum_{j \neq i} G m_j \frac{\mathbf{r}_{ij}}{(\mathbf{r}_{ij}^2 + \epsilon^2)^{3/2}} \label{eq:ap_accel_pred} \\
		\dot{\mathbf{a}}_{1, i} &= \sum_{j \neq i} G m_j \left[\frac{\mathbf{v}_{ij}}{(\mathbf{r}_{ij}^2 + \epsilon^2)^{3/2}} - \frac{3(\mathbf{v}_{ij} \cdot \mathbf{r}_{ij})\mathbf{r}_{ij}}{(\mathbf{r}_{ij}^2 + \epsilon^2)^{5/2}}\right] \label{eq:ap_jerk_pred} \\
		\mathbf{r}_{ij} &= \mathbf{r}_{p,j} - \mathbf{r}_{p,i} \\
		\mathbf{v}_{ij} &= \mathbf{v}_{p,j} - \mathbf{v}_{p,i}
	\end{align}
	
	In this notation, the subscript $0$ denotes quantities evaluated at the beginning of the time step ($t_j$), while the subscript $1$ denotes quantities evaluated at the end of the time step ($t$), using the predicted position and velocity ($\mathbf{x}_{p, i}$ and $\mathbf{v}_{p_i}$).
	
	% Cuarto Paso
	\subsection{Step 4: Second and third time derivative of acceleration, using Hermite interpolation}
	
	To obtain a high-order correction of $\mathbf{x}$ and $\mathbf{v}$, the acceleration of particle $i$ is modeled as a third-order polynomial in time:
	
	\begin{equation}
		\mathbf{a}(\tau) = \alpha \tau^3 + \beta \tau^2 + \gamma \tau + \delta \label{eq:ap_accel_pol}
	\end{equation}
	
	The successive time derivatives of $\mathbf{a}(\tau)$ are then:
	
	\begin{align}
		\dot{\mathbf{a}}(\tau) &= 3 \alpha \tau^2 + 2 \beta \tau + \gamma \label{eq:ap_jerk_pol} \\
		\mathbf{a}^{(2)} (\tau) &= 6 \alpha \tau + 2 \beta \label{eq:ap_a2_pol} \\
		\mathbf{a}^{(3)} (\tau) &= 6 \alpha \label{eq:ap_a3_pol}
	\end{align}
	
	The coefficients $\alpha$, $\beta$, $\gamma$, and $\delta$ are determined by using the known values of acceleration and jerk at times $t_i$ and $t$. This provides a system of four equations:
	
	\begin{align}
		\mathbf{a}(t_i) = \mathbf{a}_{0, i} &=  \alpha t_i^3 + \beta t_i^2 + \gamma t_i + \delta \label{eq:ap_a_ti} \\
		\mathbf{a}(t) = \mathbf{a}_{1, i} &=  \alpha t^3 + \beta t^2 + \gamma t + \delta \label{eq:ap_a_t} \\
		\dot{\mathbf{a}}(t_i) = \dot{\mathbf{a}}_{0, i} &= 3 \alpha t_i^2 + 2 \beta t_i + \gamma \label{eq:ap_adot_ti} \\
		\dot{\mathbf{a}}(t) = \dot{\mathbf{a}}_{1, i} &= 3 \alpha t^2 + 2 \beta t + \gamma \label{eq:ap_adot_t}
	\end{align}
	
	where $t = t_i + \Delta t_i$ is the current time. As the system of equations is linearly independent, the four coefficients can be determined. However, determining $\alpha$ and $\beta$ is enough to get the second and third time derivative of acceleration. From (\ref{eq:ap_adot_t}):
	
	\begin{equation}
		\gamma = \dot{\mathbf{a}}_{1, i} - 3 \alpha t^2 - 2 \beta t \label{eq:app_gamma}
	\end{equation}
	
	Subtracting Eq.~\eqref{eq:ap_adot_ti} from \eqref{eq:ap_adot_t}:
	
	\begin{equation}
		\beta = \frac{(\dot{\mathbf{a}}_{1, i} - \dot{\mathbf{a}}_{0, i}) - \alpha 3 (t^2 - t_i^2)}{2(t - t_i)} \label{eq:ap_b_var}
	\end{equation}
	
	Subtracting Eq.~\eqref{eq:ap_a_ti} from \eqref{eq:ap_a_t}, and using results from \eqref{eq:app_gamma} and \eqref{eq:ap_b_var} gives an expression for $\alpha$:
	
	\begin{equation}
		\alpha = \frac{(\dot{\mathbf{a}}_{1, i} + \dot{\mathbf{a}}_{0, i})(t - t_i) - 2(\mathbf{a}_{1, i} - \mathbf{a}_{0, i})}{(t - t_i)^3} \label{eq:ap_alpha_var}
	\end{equation}
	
	Replacing this result in Eq.~\eqref{eq:ap_b_var}:
	
	\begin{equation}
		\beta = \frac{-\dot{\mathbf{a}}_{1, i}(t + 2 t_i) - \dot{\mathbf{a}}_{0, i}(2 t + t_i)}{(t - t_i)^2} + \frac{3(\mathbf{a}_{1, i} - \mathbf{a}_{0, i})(t + t_i)}{(t - t_i)^3}
	\end{equation}
	
	The second and third time derivatives of the acceleration at time $t_i$ can now be evaluated. For the Eq.~\eqref{eq:ap_a3_pol}, and using $t - t_i = \Delta t_i$:
	
	\begin{align}
		\mathbf{a}^{(3)}_{0, i} &= \mathbf{a}^{(3)} (t_i) = 6 \alpha \\
		\mathbf{a}^{(3)}_{0, i} &= 6 \frac{(\dot{\mathbf{a}}_{1, i} + \dot{\mathbf{a}}_{0, i})\Delta t_i - 2(\mathbf{a}_{1, i} - \mathbf{a}_{0, i})}{{\Delta t_i}^3} \\
		\mathbf{a}^{(3)}_{0, i} &= \frac{12 (\mathbf{a}_{0, i} - \mathbf{a}_{1, i}) + 6(\dot{\mathbf{a}}_{0, i} + \dot{\mathbf{a}}_{1, i})\Delta t_i}{{\Delta t_i}^3} \label{eq:ap_a3_ti}
	\end{align}
	
	Evaluating the second time derivative in $t_i$, and replacing the obtained for $\alpha$ and $\beta$:
	
	\begin{align}
		\mathbf{a}^{(2)}_{0, i} &= \mathbf{a}^{(2)} (t_i) = 6 \alpha t_i + \beta \\
		\mathbf{a}^{(2)}_{0, i} &= \frac{-6(\mathbf{a}_{0, i} - \mathbf{a}_{1, i}) - \Delta t_i(4\dot{\mathbf{a}}_{0, i} + 2\dot{\mathbf{a}}_{1, i})}{{\Delta t_i}^2}
	\end{align}
	
	
	% Quinto Paso
	\subsection{Step 5: Add corrections}
	
	The next step in the scheme is to correct position and velocity of particle $i$ at time $t$. Using a higher-order Taylor expansion around $t_i$:
	
	\begin{align}
		\mathbf{x}_i(t_i + \Delta t_i) =& \mathbf{x}_i(t_i) + \dot{\mathbf{x}_i}(t_i)\Delta t_i + \frac{{\mathbf{x}_i}^{(2)}(t_i){\Delta t_i}^2}{2!} + ... + \frac{{\mathbf{x}_i}^{(5)}(t_i){\Delta t_i}^5}{5!}\\
		=& \mathbf{x}_i + \mathbf{v}_i \Delta t_i + \frac{\mathbf{a}_{0, i} {\Delta t_i}^2}{2} + \frac{\dot{\mathbf{a}}_{0, i} {\Delta t_i}^3}{6} + \frac{\mathbf{a}^{(2)}_{0, i} {\Delta t_i}^4}{24} + \frac{\mathbf{a}^{(3)}_{0, i} {\Delta t_i}^5}{120}
	\end{align}
	
	The first four terms of this expansion correspond to the predicted position $\mathbf{x}_{p, i}$ from Eq.~\eqref{eq:ap_xpred}. Therefore, the corrected position can be written as:
	
	\begin{equation}
		\mathbf{x}_i(t_i + \Delta t_i) = \mathbf{x}_{p, i} + \frac{\mathbf{a}^{(2)}_{0, i} {\Delta t_i}^4}{24} + \frac{\mathbf{a}^{(3)}_{0, i} {\Delta t_i}^5}{120} \label{eq:ap_xcorr}
	\end{equation}
	
	In a similar way, the corrected velocity is:
	
	\begin{equation}
		\mathbf{v}_i(t_i + \Delta t_i) = \mathbf{v}_{p, i} + \frac{\mathbf{a}^{(2)}_{0, i} {\Delta t_i}^3}{6} + \frac{\mathbf{a}^{(3)}_{0, i} {\Delta t_i}^4}{24} \label{eq:ap_vcorr}
	\end{equation}
	
	The advantage of this scheme is that achieving high integration accuracy only requires the explicit calculation of the acceleration and jerk for all particles, and the predicted acceleration and jerk for the particle being advanced. This results in an integration scheme that is fourth-order accurate in time ($\mathcal{O}(a^{(3)})$).
	
	\subsection{Step 6: Time step update}
	
	After updating the position and velocity of particle $i$, a new time step $\Delta t_i$ must be calculated. This step is crucial for controlling the integration error. A proven and stable criterion is given by the standard formula \cite{aarseth1985}:
	
	\begin{equation}
		\Delta t_i = \sqrt{\eta \frac{|\mathbf{a}_{1, i}| |\mathbf{a}^{(2)}_{1, i}| + |\dot{\mathbf{a}}_{1, i}|^2}{|\dot{\mathbf{a}}_{1, i}| |\mathbf{a}^{(3)}_{1, i}| + |\mathbf{a}^{(2)}_{1, i}|^2}} \label{eq:ap_tstep_std}
	\end{equation}
	
	The values for $\mathbf{a}_{1, i}$ and $\dot{\mathbf{a}}_{1, i}$ are known from the direct calculation in Step 3. The value of $\mathbf{a}^{(3)}(t)$ is constant, since a third-order polynomial interpolation is used. Only $\mathbf{a}^{(2)}_{1, i}$ should be calculated:
	
	\begin{equation}
		\mathbf{a}^{(2)}_{1, i} = \mathbf{a}^{(2)}_{0, i} + \Delta t_i \mathbf{a}^{(3)}_{0, i}
	\end{equation}
	
	During the initialization of the algorithm, the higher-order derivatives of the acceleration are not available, so an alternative formula for time step can be used in the startup:
	
	\begin{equation}
		\Delta t = \eta_s \frac{|\mathbf{a}|}{|\dot{\mathbf{a}}|} \label{eq:ap_tstep_ini}
	\end{equation}
	
	The suggested value for the startup parameter is $\eta_s \sim 0.01$ \cite{makino1992}.

\end{appendixs}